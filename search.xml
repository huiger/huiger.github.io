<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[银行卡列表之背景颜色自动识别]]></title>
    <url>%2F2018%2F08%2F23%2FbitmapGetColor%2F</url>
    <content type="text"><![CDATA[目前市场是的大部分App, 都具有个人账户功能吧, 那么当然少不了银行卡这个角色. 银行卡列表背景色若设置成统一的单色调, 那多影响美观. 若我们能把银行logo的主色调当成背景, 那逼格瞬间提升百倍呀! 首先我们要读取logo的主色调, 当然得拿到logo. 这里用到了github上的这位大兄弟抓取的数据, https://github.com/digglife/cnbankcard 那logo不可能全部都放到assets中, 多影响app体积. 个人建议放服务器. 说这么多, 先看看效果图吧. 读取主色调,我这里用到了Palette, Palette其实就是调色板, 能够读取图片的色调, 包含柔和深色的、柔和的明亮、活跃的明亮、活跃的深色… 步骤导入你需要在工程下的build.gradle里添加依赖才可以使用Palette，像如下代码所示： 123dependencies &#123; compile &apos;com.android.support:palette-v7:27.1.1&apos;&#125; 一些api123456789101112131415传入默认颜色防止Palette无法解析到指定颜色种类// 获取到柔和的深色的颜色（可传默认值） palette.getDarkMutedColor(Color.BLUE); // 获取到活跃的深色的颜色（可传默认值） palette.getDarkVibrantColor(Color.BLUE); // 获取到柔和的明亮的颜色（可传默认值） palette.getLightMutedColor(Color.BLUE); // 获取到活跃的明亮的颜色（可传默认值） palette.getLightVibrantColor(Color.BLUE); // 获取图片中最活跃的颜色（也可以说整个图片出现最多的颜色）（可传默认值） palette.getVibrantColor(Color.BLUE); // 获取图片中一个最柔和的颜色（可传默认值） palette.getMutedColor(Color.BLUE);// ... 这里省略其他的方法。 开始使用这里我们读取主色调, 什么明亮,柔和的怎么都不是想要的, 所以我这里就取像素点最多的那个色值,12345678910111213141516171819202122232425262728293031/** * 获取图片主色调 * * @param bitmap * @return */ public static void getBitmapColor(final Bitmap bitmap, final onBitmapGetColorListener listener) &#123; Palette.from(bitmap).maximumColorCount(10).generate(new Palette.PaletteAsyncListener() &#123; @Override public void onGenerated(@NonNull Palette palette) &#123; List&lt;Palette.Swatch&gt; list = palette.getSwatches(); int colorSize = 0; Palette.Swatch maxSwatch = null; for (int i = 0; i &lt; list.size(); i++) &#123; Palette.Swatch swatch = list.get(i); if (swatch != null) &#123; int population = swatch.getPopulation(); if (colorSize &lt; population) &#123; colorSize = population; maxSwatch = swatch; &#125; &#125; &#125; if (maxSwatch != null) listener.getColor(maxSwatch.getRgb()); &#125; &#125;); &#125; 那么到此颜色值获取了,直接设置背景就好了. 其他Palatte还可以和ViewGroup和Fragment搭配使用, 也是非常美观的, 盗个图片]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-可移动的标签]]></title>
    <url>%2F2018%2F04%2F28%2Fandroid-%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[虽说可移动的标签没什么难度可言, 但对于些自定义view相对薄弱的来讲, 还是有点意义的, 比如说我. 先看下我这边的效果图吧. 整个绘制过程相对比较简单. 首先onMessage中测量要具体显示的位置, 或者说能显示的大小是多少12345678910111213141516171819202122232425@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width, height; int widthSize = MeasureSpec.getSize(widthMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); if (widthMode == MeasureSpec.EXACTLY) &#123; width = Math.max(widthSize, mixWidth); //widthSize &gt; mixWidth ? widthSize : mixWidth; &#125; else &#123; width = getPaddingLeft() + mixWidth + getPaddingRight(); &#125; if (heightMode == MeasureSpec.EXACTLY) &#123; height = Math.max(heightSize, mixHeight);//heightSize &gt; mixHeight ? heightSize : mixHeight; &#125; else &#123; height = getPaddingTop() + mixHeight + getPaddingBottom(); &#125; mCircleY = height / 2; setMeasuredDimension(width, height);&#125; 绘制细线12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 绘制细线 * * @param canvas */private void drawLine(Canvas canvas) &#123; if (mStrs.length == 0) return; mLinePaint.setStyle(Paint.Style.STROKE); reSetPath(); if (mCircleX &gt; getMeasuredHeight() / 2) &#123; // 原点在右侧, 文字需要在左 asLeft = -1; lineStartX = mCircleX - mRadius * 0.6f; &#125; else &#123; asLeft = 1; lineStartX = mCircleX + mRadius * 0.6f; &#125; if (mStrs.length == 1) &#123; mPath[0].rLineTo((mTextPaint.measureText(mStrs[0]) + disGap / 2) * asLeft + disGap, 0); canvas.drawPath(mPath[0], mLinePaint); &#125; else if (mStrs.length == 2) &#123; mPath[0].lineTo(lineStartX + disGap * asLeft, mCircleY - disGap); mPath[0].rLineTo((mTextPaint.measureText(mStrs[0]) + disGap / 2) * asLeft, 0); canvas.drawPath(mPath[0], mLinePaint); mPath[1].lineTo(lineStartX + disGap * asLeft, mCircleY + disGap); mPath[1].rLineTo((mTextPaint.measureText(mStrs[1]) + disGap / 2) * asLeft, 0); canvas.drawPath(mPath[1], mLinePaint); &#125; else &#123; mPath[0].lineTo(lineStartX + disGap * asLeft, mCircleY - disGap); mPath[0].rLineTo((mTextPaint.measureText(mStrs[0]) + disGap / 2) * asLeft, 0); canvas.drawPath(mPath[0], mLinePaint); mPath[1].rLineTo((mTextPaint.measureText(mStrs[1]) + disGap * 1.5f) * asLeft, 0); canvas.drawPath(mPath[1], mLinePaint); mPath[2].lineTo(lineStartX + disGap * asLeft, mCircleY + disGap); mPath[2].rLineTo((mTextPaint.measureText(mStrs[2]) + disGap / 2) * asLeft, 0); canvas.drawPath(mPath[2], mLinePaint); &#125;&#125; 设置文字 这里只提供在java代码中设置文字, 个人觉得这样比在xml中更灵活些. 所以提供了可直接设置文字的可变数组(仅支持1-3个文字标签) 123456789101112131415/** * 设置文字 * * @param str 要显示的文字 */public void setText(String... str) &#123; if (str.length &gt; 3) &#123; mStrs[0] = str[0]; mStrs[1] = str[1]; mStrs[2] = str[2]; &#125; else &#123; this.mStrs = str; &#125; invalidate();&#125; 绘制文字 刚开始是想直接drawTextonPath, 原点在左, 文字在右,倒是好绘制. 但是反过来, 原点在右,文字在左就不好搞了,最终换成直接绘制文字. 12345678910111213141516171819202122232425/** * 绘制文字 * * @param canvas */private void drawText(Canvas canvas) &#123; if (mStrs.length == 0) return; if (asLeft &gt; 0) &#123; // 原点在左侧, 文字需要在右 mTextPaint.setTextAlign(Paint.Align.LEFT); &#125; else &#123; mTextPaint.setTextAlign(Paint.Align.RIGHT); &#125; if (mStrs.length == 1) &#123; canvas.drawText(mStrs[0], lineStartX + disGap * asLeft, mCircleY - mLineDisText, mTextPaint); &#125; else if (mStrs.length == 2) &#123; canvas.drawText(mStrs[0], lineStartX + disGap * asLeft, mCircleY - disGap - mLineDisText, mTextPaint); canvas.drawText(mStrs[1], lineStartX + disGap * asLeft, mCircleY + disGap - mLineDisText, mTextPaint); &#125; else &#123; canvas.drawText(mStrs[0], lineStartX + disGap * asLeft, mCircleY - disGap - mLineDisText, mTextPaint); canvas.drawText(mStrs[1], lineStartX + disGap * asLeft, mCircleY - mLineDisText, mTextPaint); canvas.drawText(mStrs[2], lineStartX + disGap * asLeft, mCircleY + disGap - mLineDisText, mTextPaint); &#125;&#125; 到此一个普通的带标签的view已经绘制好了, 再加些动画就更好看些了123456789101112/** * 初始化动画 */private void initAnim() &#123; mAnimator = ObjectAnimator.ofFloat(this, "progress", 0.6f, 1); mAnimator.setDuration(1000); mAnimator.setInterpolator(new AccelerateDecelerateInterpolator()); // 无限循环 mAnimator.setRepeatCount(ValueAnimator.INFINITE); // 重复模式, RESTART: 重新开始 REVERSE:恢复初始状态再开始 mAnimator.setRepeatMode(ValueAnimator.REVERSE);&#125; 整个过程就是这样,具体详细代码, 可前往Github查看全部代码]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射, 不看你可别后悔]]></title>
    <url>%2F2018%2F04%2F12%2Fjava%E5%8F%8D%E5%B0%84%2C%20%E4%B8%8D%E7%9C%8B%E4%BD%A0%E5%8F%AF%E5%88%AB%E5%90%8E%E6%82%94%2F</url>
    <content type="text"><![CDATA[开发中, 难免遇到些私有的属性和方法, 就好比下面的实体一样, 我们该怎么获得她, 并玩弄于手掌呢? 我们先来个实体瞧瞧, 给你个对象你也new不了, hahaha… 单身wang 123456789101112131415161718192021222324252627282930public class Student &#123; private String name; private int age; private Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public Student()&#123; throw new IllegalAccessError(&quot;就不给你创建&quot;); &#125; private String getName() &#123; return name == null ? &quot;&quot; : name; &#125; private void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125;&#125; 在反射中如果是私有的, 不管是私有方法, 还是私有属性, 都必须在操作前设置setAccessible为false. 你要不设, 就等着GG呗! 反射步骤1. 首先我们要找到要操作的对象 通过Class.forName(“…”), 找到你对象, 里面就写 包名+对象名, 后缀就算了, 谁不知道是个女的啊!1Class&lt;?&gt; clz = Class.forName(&quot;top.huiger.Student&quot;); 2. 找到对象在哪了, 但是我们还没找到创建的构造方法是不行的, 关于找哪个构造方法, 自己选择, 自己的对象自己找.1clz.getDeclaredConstructor(String.class, int.class); 3. 那我们来创建她, 记得上面的找的构造方法是什么, 要匹配上才行.1Object student = constructor.newInstance(&quot;张三&quot;, 18); // 张三还是如花 看你爱好 4. 找到对象了, 我们来调用下, 但是公开的和私有的又有区别 公开 clz.getMethod(“getAge”); 12Method getAge = clz.getMethod(&quot;getAge&quot;);System.out.println(&quot;--------------&quot; + getAge.invoke(student)); 私有 clz.getDeclaredMethod(“getName”);, 上面说过, 私有的都要设置可修改的权限 1234Method getName = clz.getDeclaredMethod(&quot;getName&quot;);getName.setAccessible(true);String name = (String) getName.invoke(student);System.out.println(&quot;--------------&quot; + name); 5. 修改属性, 和调用方法类似12345// 找到私有属性Field age = clz.getDeclaredField(&quot;age&quot;);age.setAccessible(true);age.setInt(student, 20); // 修改属性System.out.println(&quot;--------------&quot;+age.get(student)); 全部演练代码都在这12345678910111213141516171819Class&lt;?&gt; clz = Class.forName(&quot;top.huiger.Student&quot;);// 找到带有这个参数的构造方法Constructor constructor = clz.getDeclaredConstructor(String.class, int.class);constructor.setAccessible(true);// 初始化对象Object student = constructor.newInstance(&quot;张三&quot;, 18);System.out.println(&quot;--------------&quot;+constructor.toString());// 找到该私有方法Method getName = clz.getDeclaredMethod(&quot;getName&quot;);getName.setAccessible(true);String name = (String) getName.invoke(student);System.out.println(&quot;--------------&quot;+name);// 找到私有属性Field age = clz.getDeclaredField(&quot;age&quot;);age.setAccessible(true);age.setInt(student, 20); // 修改属性System.out.println(&quot;--------------&quot;+age.get(student)); 最后输出123--------------private com.dong.wine.Student(java.lang.String,int)--------------张三--------------20]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown - 编辑美化]]></title>
    <url>%2F2017%2F05%2F14%2FMarkDown-%E7%BC%96%E8%BE%91%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[字体、字号、颜色123456&lt;font face="黑体"&gt;我是黑体字&lt;/font&gt;&lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt;&lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face="黑体"&gt;color=#0099ff size=72 face="黑体"&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt; 效果我是黑体字我是微软雅黑我是华文彩云color=#0099ff size=72 face=”黑体”color=#00ffffcolor=gray]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown - 编辑语法]]></title>
    <url>%2F2017%2F03%2F27%2FMarkDown-%E7%BC%96%E8%BE%91%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[代码块 用TAB键起始的段落 用```包裹代码快```（代码高亮```(语言类型) 包裹代码快```） 用4个空格开头 列如：1234```javapublic void test()&#123; System.out.print(&quot;hello world!&quot;);&#125; 效果：123public void test()&#123; System.out.print("hello world!");&#125; 行内引用如果在一个行内需要引用代码，只要用反引号`引起来就好 如果在一个行内需要引用代码，只要用`反引号`引起来就好 如果在一个行内需要引用代码，只要用反引号引起来就好 分割线 -–***___ 效果 删除线~~删除我吧~~ 效果删除我吧 引用 > 引用 效果 引用 无序列表符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表，内容可超长1234- 无序列表- 无序列表- 无序列表- 无序列表： 效果 无序列表 无序列表 无序列表 无序列表： 列表有序列表1231. 有序列表2. 有序列表3. 有序列表 效果 有序列表 有序列表 有序列表 嵌套列表123456- 嵌套列表1 + 嵌套列表2 + 嵌套列表3 - 嵌套列表4 * 嵌套列表5- 嵌套列表6 效果 嵌套列表1 嵌套列表2 嵌套列表3 嵌套列表4 嵌套列表5 嵌套列表6 表格可以使用冒号来定义表格的对齐方式，如下： 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 效果 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 链接文字链接[HuiGer的博客](http://huiger.top &quot;HuiGer的博客&quot;) HuiGer的博客 图片链接多个感叹号，Tooltips可省略，要设置大小只能借助HTML标记 ![Baidu](https://www.baidu.com/img/bd_logo1.png &quot;Baidu&quot;) 转义字符和java中的相似，只要在需要显示原字符的前面加\， 如下： 1234567891011121314\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号等 \ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 制作待办事项To-do List 高效绘制 流程图、序列图、甘特图、表格流程图： 序列图 甘特图 书写数学公式]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android App内监听截图加二维码]]></title>
    <url>%2F2016%2F08%2F03%2Fandroid-App%E5%86%85%E7%9B%91%E5%90%AC%E6%88%AA%E5%9B%BE%E5%8A%A0%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Android截屏功能是一个常用的功能，可以方便的用来分享或者发送给好友，本文介绍了如何实现app内截屏监控功能，当发现用户在我们的app内进行了截屏操作时，进行对图片的二次操作，例如添加二维码，公司logo等一系列*。 项目地址测试截图： 截屏原理Android系统并没有提供截屏通知相关的API，需要我们自己利用系统能提供的相关特性变通实现。Android系统有一个媒体数据库，每拍一张照片，或使用系统截屏截取一张图片，都会把这张图片的详细信息加入到这个媒体数据库，并发出内容改变通知，我们可以利用内容观察者（ContentObserver）监听媒体数据库的变化，当数据库有变化时，获取最后插入的一条图片数据，如果该图片符合特定的规则，则认为被截屏了。 判断依据当ContentObserver监听到媒体数据库的数据改变, 在有数据改变时 获取最后插入数据库的一条图片数据, 如果符合以下规则, 则认为截屏了: 时间判断，图片的生成时间在开始监听之后,并与当前时间相隔10秒内：开始监听后生成的图片才有意义，相隔10秒内说明是刚刚生成的 尺寸判断，图片的尺寸没有超过屏幕的尺寸：图片尺寸超过屏幕尺寸，不可能是截屏图片 路径判断，图片路径符合包含特定的关键词：这一点是关键，截屏图片的保存路径通常包含“screenshot” 这些判断是为了增加截屏检测结果的可靠性，防止误报，防止遗漏。其中截屏图片的路径正常Android系统保存的路径格式， 例如我的是：“外部存储器/storage/emulated/0/Pictures/Screenshots/Screenshot_2017-08-03-15-42-58.png”，但Android系统碎片化严重，加上其他第三方截屏APP等，所以路径关键字除了检查是否包含“screenshot”外，还可以适当增加其他关键字，详见最后的监听器完整代码。这种监听截屏的方法也不是100%准确，例如某些被root的机器使用第三方截屏APP自定义保存路径，还比如通过ADB命令在电脑上获取手机屏幕快照均不能监听到，但这也是目前可行性最高的方法，对于绝大多数用户都比较靠谱。 代码描述监听截屏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387public class ScreenShotListenManager &#123; private static final String TAG = "ScreenShotListenManager"; /** * 读取媒体数据库时需要读取的列 */ private static final String[] MEDIA_PROJECTIONS = &#123; MediaStore.Images.ImageColumns.DATA, MediaStore.Images.ImageColumns.DATE_TAKEN, &#125;; /** * 读取媒体数据库时需要读取的列, 其中 WIDTH 和 HEIGHT 字段在 API 16 以后才有 */ private static final String[] MEDIA_PROJECTIONS_API_16 = &#123; MediaStore.Images.ImageColumns.DATA, MediaStore.Images.ImageColumns.DATE_TAKEN, MediaStore.Images.ImageColumns.WIDTH, MediaStore.Images.ImageColumns.HEIGHT, &#125;; /** * 截屏依据中的路径判断关键字 */ private static final String[] KEYWORDS = &#123; "screenshot", "screen_shot", "screen-shot", "screen shot", "screencapture", "screen_capture", "screen-capture", "screen capture", "screencap", "screen_cap", "screen-cap", "screen cap" &#125;; private static Point sScreenRealSize; /** * 已回调过的路径 */ private final static List&lt;String&gt; sHasCallbackPaths = new ArrayList&lt;String&gt;(); private Context mContext; private OnScreenShotListener mListener; private long mStartListenTime; /** * 内部存储器内容观察者 */ private MediaContentObserver mInternalObserver; /** * 外部存储器内容观察者 */ private MediaContentObserver mExternalObserver; /** * 运行在 UI 线程的 Handler, 用于运行监听器回调 */ private final Handler mUiHandler = new Handler(Looper.getMainLooper()); private ScreenShotListenManager(Context context) &#123; if (context == null) &#123; throw new IllegalArgumentException("The context must not be null."); &#125; mContext = context; // 获取屏幕真实的分辨率 if (sScreenRealSize == null) &#123; sScreenRealSize = getRealScreenSize(); if (sScreenRealSize != null) &#123; Log.d(TAG, "Screen Real Size: " + sScreenRealSize.x + " * " + sScreenRealSize.y); &#125; else &#123; Log.w(TAG, "Get screen real size failed."); &#125; &#125; &#125; public static ScreenShotListenManager newInstance(Context context) &#123; assertInMainThread(); return new ScreenShotListenManager(context); &#125; /** * 启动监听 */ public void startListen() &#123; assertInMainThread();// sHasCallbackPaths.clear(); // 记录开始监听的时间戳 mStartListenTime = System.currentTimeMillis(); // 创建内容观察者 mInternalObserver = new MediaContentObserver(MediaStore.Images.Media.INTERNAL_CONTENT_URI, mUiHandler); mExternalObserver = new MediaContentObserver(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, mUiHandler); // 注册内容观察者 mContext.getContentResolver().registerContentObserver( MediaStore.Images.Media.INTERNAL_CONTENT_URI, false, mInternalObserver ); mContext.getContentResolver().registerContentObserver( MediaStore.Images.Media.EXTERNAL_CONTENT_URI, false, mExternalObserver ); &#125; /** * 停止监听 */ public void stopListen() &#123; assertInMainThread(); // 注销内容观察者 if (mInternalObserver != null) &#123; try &#123; mContext.getContentResolver().unregisterContentObserver(mInternalObserver); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; mInternalObserver = null; &#125; if (mExternalObserver != null) &#123; try &#123; mContext.getContentResolver().unregisterContentObserver(mExternalObserver); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; mExternalObserver = null; &#125; // 清空数据 mStartListenTime = 0;// sHasCallbackPaths.clear(); //切记！！！:必须设置为空 可能mListener 会隐式持有Activity导致释放不掉 mListener = null; &#125; /** * 处理媒体数据库的内容改变 */ private void handleMediaContentChange(Uri contentUri) &#123; Cursor cursor = null; try &#123; // 数据改变时查询数据库中最后加入的一条数据 cursor = mContext.getContentResolver().query( contentUri, Build.VERSION.SDK_INT &lt; 16 ? MEDIA_PROJECTIONS : MEDIA_PROJECTIONS_API_16, null, null, MediaStore.Images.ImageColumns.DATE_ADDED + " desc limit 1" ); if (cursor == null) &#123; Log.e(TAG, "Deviant logic."); return; &#125; if (!cursor.moveToFirst()) &#123; Log.d(TAG, "Cursor no data."); return; &#125; // 获取各列的索引 int dataIndex = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA); int dateTakenIndex = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATE_TAKEN); int widthIndex = -1; int heightIndex = -1; if (Build.VERSION.SDK_INT &gt;= 16) &#123; widthIndex = cursor.getColumnIndex(MediaStore.Images.ImageColumns.WIDTH); heightIndex = cursor.getColumnIndex(MediaStore.Images.ImageColumns.HEIGHT); &#125; // 获取行数据 String data = cursor.getString(dataIndex); long dateTaken = cursor.getLong(dateTakenIndex); int width = 0; int height = 0; if (widthIndex &gt;= 0 &amp;&amp; heightIndex &gt;= 0) &#123; width = cursor.getInt(widthIndex); height = cursor.getInt(heightIndex); &#125; else &#123; // API 16 之前, 宽高要手动获取 Point size = getImageSize(data); width = size.x; height = size.y; &#125; // 处理获取到的第一行数据 handleMediaRowData(data, dateTaken, width, height); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null &amp;&amp; !cursor.isClosed()) &#123; cursor.close(); &#125; &#125; &#125; private Point getImageSize(String imagePath) &#123; BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeFile(imagePath, options); return new Point(options.outWidth, options.outHeight); &#125; /** * 处理获取到的一行数据 */ private void handleMediaRowData(String data, long dateTaken, int width, int height) &#123; if (checkScreenShot(data, dateTaken, width, height)) &#123; Log.d(TAG, "ScreenShot: path = " + data + "; size = " + width + " * " + height + "; date = " + dateTaken); if (mListener != null &amp;&amp; !checkCallback(data)) &#123; mListener.onShot(data); &#125; &#125; else &#123; // 如果在观察区间媒体数据库有数据改变，又不符合截屏规则，则输出到 log 待分析 Log.w(TAG, "Media content changed, but not screenshot: path = " + data + "; size = " + width + " * " + height + "; date = " + dateTaken); &#125; &#125; /** * 判断指定的数据行是否符合截屏条件 */ private boolean checkScreenShot(String data, long dateTaken, int width, int height) &#123; /* * 判断依据一: 时间判断 */ // 如果加入数据库的时间在开始监听之前, 或者与当前时间相差大于10秒, 则认为当前没有截屏 if (dateTaken &lt; mStartListenTime || (System.currentTimeMillis() - dateTaken) &gt; 10 * 1000) &#123; return false; &#125; /* * 判断依据二: 尺寸判断 */ if (sScreenRealSize != null) &#123; // 如果图片尺寸超出屏幕, 则认为当前没有截屏 if (!((width &lt;= sScreenRealSize.x &amp;&amp; height &lt;= sScreenRealSize.y) || (height &lt;= sScreenRealSize.x &amp;&amp; width &lt;= sScreenRealSize.y))) &#123; return false; &#125; &#125; /* * 判断依据三: 路径判断 */ if (TextUtils.isEmpty(data)) &#123; return false; &#125; data = data.toLowerCase(); // 判断图片路径是否含有指定的关键字之一, 如果有, 则认为当前截屏了 for (String keyWork : KEYWORDS) &#123; if (data.contains(keyWork)) &#123; return true; &#125; &#125; return false; &#125; /** * 判断是否已回调过, 某些手机ROM截屏一次会发出多次内容改变的通知; &lt;br/&gt; * 删除一个图片也会发通知, 同时防止删除图片时误将上一张符合截屏规则的图片当做是当前截屏. */ private boolean checkCallback(String imagePath) &#123; if (sHasCallbackPaths.contains(imagePath)) &#123; Log.d(TAG, "ScreenShot: imgPath has done" + "; imagePath = " + imagePath); return true; &#125; // 大概缓存15~20条记录便可 if (sHasCallbackPaths.size() &gt;= 20) &#123; for (int i = 0; i &lt; 5; i++) &#123; sHasCallbackPaths.remove(0); &#125; &#125; sHasCallbackPaths.add(imagePath); return false; &#125; /** * 获取屏幕分辨率 */ private Point getRealScreenSize() &#123; Point screenSize = null; try &#123; screenSize = new Point(); WindowManager windowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); Display defaultDisplay = windowManager.getDefaultDisplay(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; defaultDisplay.getRealSize(screenSize); &#125; else &#123; try &#123; Method mGetRawW = Display.class.getMethod("getRawWidth"); Method mGetRawH = Display.class.getMethod("getRawHeight"); screenSize.set( (Integer) mGetRawW.invoke(defaultDisplay), (Integer) mGetRawH.invoke(defaultDisplay) ); &#125; catch (Exception e) &#123; screenSize.set(defaultDisplay.getWidth(), defaultDisplay.getHeight()); e.printStackTrace(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return screenSize; &#125; public Bitmap createScreenShotBitmap(Context context, String screenFilePath) &#123; View v = LayoutInflater.from(context).inflate(R.layout.share_screenshot_layout, null); ImageView iv = (ImageView) v.findViewById(R.id.iv); Bitmap bitmap = BitmapFactory.decodeFile(screenFilePath); iv.setImageBitmap(bitmap); //整体布局 Point point = getRealScreenSize(); v.measure(View.MeasureSpec.makeMeasureSpec(point.x, View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(point.y, View.MeasureSpec.EXACTLY)); v.layout(0, 0, point.x, point.y);// Bitmap result = Bitmap.createBitmap(v.getWidth(), v.getHeight(), Bitmap.Config.RGB_565); Bitmap result = Bitmap.createBitmap(v.getWidth(), v.getHeight() + dp2px(context, 140), Bitmap.Config.ARGB_8888); Canvas c = new Canvas(result); c.drawColor(Color.WHITE); // Draw view to canvas v.draw(c); return result; &#125; private int dp2px(Context ctx, float dp) &#123; float scale = ctx.getResources().getDisplayMetrics().density; return (int) (dp * scale + 0.5f); &#125; /** * 设置截屏监听器 */ public void setListener(OnScreenShotListener listener) &#123; mListener = listener; &#125; public interface OnScreenShotListener &#123; void onShot(String imagePath); &#125; private static void assertInMainThread() &#123; if (Looper.myLooper() != Looper.getMainLooper()) &#123; StackTraceElement[] elements = Thread.currentThread().getStackTrace(); String methodMsg = null; if (elements != null &amp;&amp; elements.length &gt;= 4) &#123; methodMsg = elements[3].toString(); &#125; throw new IllegalStateException("Call the method must be in main thread: " + methodMsg); &#125; &#125; /** * 媒体内容观察者(观察媒体数据库的改变) */ private class MediaContentObserver extends ContentObserver &#123; private Uri mContentUri; public MediaContentObserver(Uri contentUri, Handler handler) &#123; super(handler); mContentUri = contentUri; &#125; @Override public void onChange(boolean selfChange) &#123; super.onChange(selfChange); handleMediaContentChange(mContentUri); &#125; &#125;&#125; 全局使用我们需求是要在APP中全局都能监听截屏操作，所以，我们只需要在BaseActivity中进行监听就可以了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Overrideprotected void onResume() &#123; super.onResume(); startScreenShotListen();&#125;@Overrideprotected void onPause() &#123; super.onPause(); stopScreenShotListen();&#125;/** * 监听 */private void startScreenShotListen() &#123; if (!isHasScreenShotListener &amp;&amp; screenShotListenManager != null) &#123; screenShotListenManager.setListener(new ScreenShotListenManager.OnScreenShotListener() &#123; @Override public void onShot(String imagePath) &#123; path = imagePath; Log.d("msg", "BaseActivity -&gt; onShot: " + "获得截图路径：" + imagePath); MyDialog ksDialog = MyDialog.getInstance() .init(BaseActivity.this, R.layout.dialog_layout) .setCancelButton("取消", null) .setPositiveButton("查看", new MyDialog.OnClickListener() &#123; @Override public void OnClick(View view) &#123; Bitmap screenShotBitmap = screenShotListenManager.createScreenShotBitmap(mContext, path); // 此处只要分享这个合成的Bitmap图片就行了 // 为了演示，故写下面代码 screenShotIv.setImageBitmap(screenShotBitmap); &#125; &#125;); screenShotIv = (ImageView) ksDialog.getView(R.id.iv); progressBar = (ProgressBar) ksDialog.getView(R.id.avLoad); mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; progressBar.setVisibility(View.GONE); Glide.with(mContext).load(path).into(screenShotIv); &#125; &#125;, 1500); &#125; &#125;); screenShotListenManager.startListen(); isHasScreenShotListener = true; &#125;&#125;/** * 停止监听 */private void stopScreenShotListen() &#123; if (isHasScreenShotListener &amp;&amp; screenShotListenManager != null) &#123; screenShotListenManager.stopListen(); isHasScreenShotListener = false; &#125;&#125; 至此APP内监听截屏操作就完成了，我们需要在baseActivity中执行监听并执行相应操作，不需要写更多代码。 项目地址&gt;&gt;]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>二维码</tag>
        <tag>截图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gradlew常用命令]]></title>
    <url>%2F2016%2F06%2F02%2Fgradlew%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[gradlew常用命令 gradlew -v 版本号 gradlew clean 清除工程目录下的build文件夹 gradlew build 检查依赖并编译打包 这里注意的是 gradlew build 命令把debug、release环境的包都打出来，如果正式发布只需要打Release的包，该怎么办呢，下面介绍一个很有用的命令 assemble, 如 gradlew assembleDebug 编译并打Debug包 gradlew assembleRelease 编译并打Release的包 还有打渠道包，如百度 gradlew assembleBaiduRelease 编译并打Release的百度包 除此之外，assemble还可以和productFlavors结合使用,比如定义了 installRelease ，uninstallRelease 两个productFlavors，则可以如下命令： gradlew installRelease Release 模式打包并安装 gradlew uninstallRelease 卸载Release模式包]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>gradlew</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云音乐外链生成最新方法]]></title>
    <url>%2F2016%2F05%2F15%2F%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E5%A4%96%E9%93%BE%E7%94%9F%E6%88%90%E6%9C%80%E6%96%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[网易云生成外链有点坑，音乐地址都没有，生成外链也不能满足我们这帮瞎扯淡的猿。所有下面就给出了可以获得网易云音乐真实地址的方法： 找到你要获得外链的歌曲，用网页版打开，复制链接中的歌曲ID 如：Panama - Matteohttp://music.163.com/#/song?id=34229976 ID就是34229976 将ID替换到链接 http://music.163.com/song/media/outer/url?id=#.mp3 中(将#换成你的ID) 如：http://music.163.com/song/media/outer/url?id=34229976.mp3 复制这个链接 就可以直接通过网页打开纯mp3地址了 添加到下载工具中也可下载 还能添加到QQ空间背景音乐中]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 简单命令发布博客]]></title>
    <url>%2F2016%2F05%2F13%2Fhexo-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo命令hexo简单命令 让发布文章不再复杂 12345678910hexo init &lt;folder&gt; #初始化一个网站目录 我是直接cd到目标目录执行hexo init的hexo new &quot;postName&quot; #新建文章，或者source\_posts手动编辑hexo new page &quot;pageName&quot; #新建页面 默认链接为:主页地址/pageName/hexo clean #清除缓存文件db.json和已生成的静态文件publichexo generate #生成public静态文件至public目录hexo server #本地发布预览效果 http://localhost:4000 (&apos;ctrl + c&apos;关闭server)hexo deploy #将.deploy目录部署到GitHubhexo --debug #在终端中显示调试信息并记录到 `debug.log`hexo help #查看帮助hexo version #查看Hexo的版本 Hexo简写命令1234hexo n &quot;postName&quot; #新建文章，或者source\_posts手动编辑hexo g #生成public静态文件至public目录hexo s #本地发布预览效果 http://localhost:4000 (&apos;ctrl + c&apos;关闭server)hexo d #将.deploy目录部署到GitHub Hexo复合命令使用下面的命令将使你更便捷、高效的写文章。 1234hexo d -g #生成并部署上传hexo s -g #生成并本地发布预览hexo clean &amp;&amp; hexo d -g #清空缓存然后生成并部署上传hexo clean &amp;&amp; hexo s -g #清空缓存然后生成并本地发布预览]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
